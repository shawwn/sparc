#!bin/arc

; adapted from test.l in https://github.com/sctb/lumen

(or= tests* (obj))

(mac test! (x msg)
  `(if (no ,x)
       (do (= failed* (+ failed* 1))
           (return ,msg))
     (++ passed*)))

(def equal? (a b)
  (is (writes a) (writes b)))

(mac test? (a b)
  (letu (x y)
    `(withs (,x ,a ,y ,b)
       (test! (equal? ,x ,y)
              (+ "failed: expected " (writes ,x) ", was " (writes ,y)
                 " for " (writes '(test? ,a ,b)))))))

(mac define-test (name . body)
  (let label (+ 'test- name)
    `(do (def ,label ()
           (point return ,@body))
         (= (tests* ',name) ,label))))

(def run-tests ()
  (= passed* 0 failed* 0)
  (each (name f) tests*
    (let result (f)
      (when (isa!string result)
        (prn (+ " " name " " result)))))
  (prn (+ " " passed* " passed, " failed* " failed")))

(define-test reader
  (let read quoted:read
    (test? eof (read ""))
    (test? nil (read "nil"))
    (test? 17 (read "17"))
    (test? 1000 (read "1_000"))
    (test? 0.015 (read "1.5e-2"))
    (test? 15 (read "0xF"))
    (test? 15 (read "+0xF"))
    (test? -15 (read "-0Xf"))
    (test? 15 (read "0b1111"))
    (test? -15 (read "-0b1111"))
    (test? 71 (read "0b0100_0111"))
    (test? -71 (read "-0b0100_0111"))
    (test? 15 (read "0o17"))
    (test? -15 (read "-0o17"))
    (test? 15.5 (read "0xf.8"))
    (test? -15.5 (read "-0xf.8"))
    (test? '0x (read "0x"))
    (test? '-0X (read "-0X"))
    (test? '-0Xg (read "-0Xg"))
    (test? '_1 (read "_1"))
    (test? '-_1 (read "-_1"))
    (test? (sym "--1") (read "--1"))
    (test? (sym "+-1") (read "+-1"))
    (test? 1 (read "+1"))
    (test? t (read "t"))
    (test? (no t) (read "false"))
    (test? 'hi (read "hi"))
    (test? '"hi" (read "\"hi\""))
    (test? 'hi (read "|hi|"))
    (test? '(1 2) (read "(1 2)"))
    (test? '(1 (a)) (read "(1 (a))"))
    (test? '(quote a) (read "'a"))
    (test? '(quasiquote a) (read "`a"))
    (test? '(quasiquote (unquote a)) (read "`,a"))
    (test? '(quasiquote (unquote-splicing a)) (read "`,@@a"))
    ;(test? 2 (# (read "(1 2 a: 7)")))
    ;(test? 7 (get (read "(1 2 a: 7)") 'a))
    ;(test? t (get (read "(:a)") 'a))
    (test? 1 (- -1))
    (test? '0? (read "0?"))
    (test? '0! (read "0!"))
    (test? '0. (read "0."))))

;(define-test read-more
;  (let read (get reader 'read-string)
;    (test? 17 (read "17" true))
;    (let more ()
;      (test? more (read "(open" more))
;      (test? more (read "\"unterminated " more))
;      (test? more (read "|identifier" more))
;      (test? more (read "'(a b c" more))
;      (test? more (read "`(a b c" more))
;      (test? more (read "`(a b ,(z" more))
;      (test? more (read "`\"biz" more))
;      (test? more (read "'\"boz" more)))
;    (let ((ok e) (guard (read "(open")))
;      (test? false ok)
;      (test? "Expected ) at 5" (get e 'message)))))

(define-test null
  (test? true (null nil))
  (test? true (null unset))
  (test? true (null (void)))
  (test? false (null true))
  (test? false (null false))
  (test? false (null (obj))))

;(define-test is?
;  (test? false (is? nil))
;  (test? false (is? null))
;  (test? true (is? true))
;  (test? true (is? false))
;  (test? true (is? (obj))))

(define-test no
  (test? true (no nil))
  (test? true (no unset))
  (test? true (no (void)))
  (test? false (no true))
  (test? true (no false))
  (test? false (no (obj)))
  (test? false (no 0)))

(define-test yes
  (test? false (yes nil))
  (test? false (yes unset))
  (test? false (yes (void)))
  (test? true (yes true))
  (test? false (yes false))
  (test? true (yes (obj)))
  (test? true (yes 0)))

(define-test boolean
  (test? true (or true false))
  (test? false (or false false))
  (test? true (or false false true))
  (test? true (no false))
  (test? true (no (and false true)))
  (test? false (no (or false true)))
  (test? true (and true true))
  (test? false (and true false))
  (test? false (and true true false)))

(define-test short
  (test? true (or true (err 'bad)))
  (test? false (and false (err 'bad)))
  (let a true
    (test? true (or true (do (= a false) false)))
    (test? true a)
    (test? false (and false (do (= a false) true)))
    (test? true a))
  (let b true
    (test? true (or (do (= b false) false) (do (= b true) b)))
    (test? true b)
    (test? true (or (do (= b true) b) (do (= b true) b)))
    (test? true b)
    (test? true (and (do (= b false) true) (do (= b true) b)))
    (test? true b)
    (test? false (and (do (= b false) b) (do (= b true) b)))
    (test? false b)))

(define-test numeric
  (test? 4 (+ 2 2))
  (test? 0 (apply * '(0 0)))
  (test? 4 (apply + '(2 2)))
  (test? 0 (apply + ()))
  (test? 4 (- 7 3))
  (test? 4 (apply - '(7 3)))
  ;(test? 0 (apply - ()))
  (test? 5 (/ 10 2))
  (test? 5 (apply / '(10 2)))
  ;(test? 1 (apply / ()))
  (test? 6.0 (* 2 3.00))
  (test? 6.0 (apply * '(2 3.00)))
  ;(test? 1 (apply * ()))
  (test? true (> 2.01 2))
  (test? true (>= 5.0 5.0))
  (test? true (> 2.1e3 2000))
  (test? true (< 2e-3 0.0021))
  (test? false (< 2 2))
  (test? true (<= 2 2))
  (test? true (is 2 2.0))
  (test? true (is -0.0 +0.0))
  (test? -7 (- 7))
  ;(test? false (numeric ""))
  )

(define-test math
  (test? 3 (max 1 3))
  (test? 2 (min 2 7))
  (let n (rand)
    (test? true (and (> n 0) (< n 1))))
  (test? 4 (trunc 4.78)))

(define-test precedence
  (test? -3 (- (+ 1 2)))
  (test? 10 (- 12 (+ 1 1)))
  (test? 11 (- 12 (* 1 1)))
  (test? 10 (+ (/ 4 2) 8)))

(define-test infix
  (withs (l '(1 1 2 3)
          (a b c d) l)
    (test? true (apply <= l))
    (test? false (apply < l))
    (test? false (apply is l))
    (test? true ((do is) 1 a b))
    (test? false (apply > (rev l)))
    (test? true (apply >= (rev l)))
    (test? true (<= a b c d))
    (test? true (<= a b c d))
    (test? false (< a b c d))
    (test? false (is a b c d))
    (test? true (is 1 a b))
    (test? false (> d c b a))
    (test? true (>= d c b a))))

;(define-test standalone
;  (test? 10 (do (+ illegal) 10))
;  (let x nil
;    (test? 9 (do (list nothing fooey (= x 10)) 9))
;    (test? 10 x))
;  (test? 12 (do (get but zz) 12))
;  (let y nil
;    (let ignore (do (%literal y | = 10;|) 42)
;      (test? 10 y))))

(define-test string
  (test? 3 (len "foo"))
  (test? 3 (len "\"a\""))
  ;(test? 'a "a")
  (test? #\a ("bar" 1))
  (test? #\a (coerce "a" 'char))
  (let s "a
b"
    (test? 3 (len s)))
  (let s "a
b
c"
    (test? 5 (len s)))
  (test? 3 (len "a\nb"))
  (test? 3 (len "a\\b"))
  (test? "x3" (cat "x" (+ 1 2))))

(define-test atstrings
  (let a 'foo
    (test? "foobar" "@{a}bar")
    (test? "" "@unset")
    (test? "" "@nil")
    (test? "" "@(list)")
    (test? "t" "@t")
    (test? "false" "@false")))

(define-test quote
  (test? 7 (quote 7))
  (test? true (quote t))
  (test? false (quote false))
  (test? nil (quote nil))
  (test? (quote a) 'a)
  (test? (quote (quote a)) ''a)
  (test? "a" '"a")
  (test? "\n" (quote "\n"))
  (test? "\r\n" (quote "\r\n"))
  (test? "\\" (quote "\\"))
  (test? '(quote "a") ''"a")
  (test? '|(| '|(|)
  (test? (quote unquote) 'unquote)
  (test? (quote (unquote)) '(unquote))
  (test? (quote (unquote a)) '(unquote a))
  ;(let x '(10 20 a: 33 1a: 44)
  ;  (test? 20 (at x 1))
  ;  (test? 33 (get x 'a))
  ;  (test? 44 (get x '1a)))
  )

(define-test list
  (test? '() (list))
  (test? () (list))
  (test? '(a) (list 'a))
  (test? '(false) (list false))
  (test? '(a) (quote (a)))
  (test? '(()) (list (list)))
  (test? 0 (len (list)))
  (test? 2 (len (list 1 2)))
  (test? '(1 2 3) (list 1 2 3))
  ;(test? 17 (get (list foo: 17) 'foo))
  ;(test? 17 (get (list 1 foo: 17) 'foo))
  ;(test? true (get (list :foo) 'foo))
  ;(test? true (get '(:foo) 'foo))
  ;(test? true (get (hd '((:foo))) 'foo))
  ;(test? '(:a) (list :a))
  (test? '(b: false) (list b: false))
  (test? '(c: 0) (list c: 0))
  (let d 42
    (test? `(d: ,d) (list :d))))

(define-test quasiquote
  (test? (quote a) (quasiquote a))
  (test? 'a `a)
  (test? () `())
  (test? 2 `,2)
  (test? nil `(,@nil))
  (let a 42
    (test? 42 `,a)
    (test? 42 (quasiquote (unquote a)))
    (test? '(quasiquote (unquote a)) ``,a)
    (test? '(quasiquote (unquote 42)) ``,,a)
    (test? '(quasiquote (quasiquote (unquote (unquote a)))) ```,,a)
    (test? '(quasiquote (quasiquote (unquote (unquote 42)))) ```,,,a)
    (test? '(a (quasiquote (b (unquote c)))) `(a `(b ,c)))
    (test? '(a (quasiquote (b (unquote 42)))) `(a `(b ,,a)))
    (let b 'c
      (test? '(quote c) `',b)
      (test? '(42) `(,a))
      (test? '((42)) `((,a)))
      (test? '(41 (42)) `(41 (,a)))))
  (let c '(1 2 3)
    (test? '((1 2 3)) `(,c))
    (test? '(1 2 3) `(,@c))
    (test? '(0 1 2 3) `(0 ,@c))
    (test? '(0 1 2 3 4) `(0 ,@c 4))
    (test? '(0 (1 2 3) 4) `(0 (,@c) 4))
    (test? '(1 2 3 1 2 3) `(,@c ,@c))
    (test? '((1 2 3) 1 2 3) `((,@c) ,@c)))
  (let a 42
    (test? '(quasiquote ((unquote-splicing (list a)))) ``(,@(list a)))
    (test? '(quasiquote ((unquote-splicing (list 42)))) ``(,@(list ,a))))
  ;(test? true (get `(:foo) 'foo))
  ;(let (a 17
  ;      b '(1 2)
  ;      c (obj a: 10)
  ;      d (list a: 10))
  ;  (test? 17 (get `(foo: ,a) 'foo))
  ;  (test? 2 (# `(foo: ,a ,@b)))
  ;  (test? 17 (get `(foo: ,@a) 'foo))
  ;  (test? '(1 a: 10) `(1 ,@c))
  ;  (test? '(1 a: 10) `(1 ,@d))
  ;  (test? true (get (hd `((:foo))) 'foo))
  ;  (test? true (get (hd `(,(list :foo))) 'foo))
  ;  (test? true (get `(,@(list :foo)) 'foo))
  ;  (test? true (get `(1 2 3 ,@'(:foo)) 'foo)))
  ;(let-macro ((a keys `(obj ,@keys)))
  ;  (test? true (get (a :foo) 'foo))
  ;  (test? 17 (get (a bar: 17) 'bar)))
  ;(let-macro ((a () `(obj baz: (fn () 17))))
  ;  (test? 17 ((get (a) 'baz))))
  )

(define-test quasiexpand
  (withs (x 'x z 'z)
    (test? 'a (macex 'a))
    (test? '(17) (macex '(17)))
    (test? '(1 z) (macex '(1 z)))
    (test? '(quasiquote (1 z)) (macex '`(1 z)))
    (test? '(quasiquote ((unquote 1) (unquote z))) (macex '`(,1 ,z)))
    (test? '(1 z) `(1 z))
    (test? '(1 z) `(,1 ,z))
    (let z '(z)
      (test? '(z) `(,@z)))
    ;(test? '(join (%array 1) z) (macex '`(,1 ,@z)))
    ;(test? '(join (%array 1) x y) (macex '`(,1 ,@x ,@y)))
    ;(test? '(join (%array 1) z (%array 2)) (macex '`(,1 ,@z ,2)))
    ;(test? '(join (%array 1) z (%array "a")) (macex '`(,1 ,@z a)))
    ;(test? '"x" (macex '`x))
    ;(test? '(%array "quasiquote" "x") (macex '``x))
    ;(test? '(%array "quasiquote" (%array "quasiquote" "x")) (macex '```x))
    ;(test? 'x (macex '`,x))
    ;(test? '(%array "quote" x) (macex '`',x))
    ;(test? '(%array "quasiquote" (%array "x")) (macex '``(x)))
    ;(test? '(%array "quasiquote" (%array "unquote" "a")) (macex '``,a))
    ;(test? '(%array "quasiquote" (%array (%array "unquote" "x")))
    ;       (macex '``(,x)))))
    ))

(define-test calls
  (withs (f (fn () 42)
          l (list f)
          t (obj f: f))
    (f)
    ((fn ()
      (test? 42 (f))))
    (test? 42 ((l 0)))
    (test? 42 ((t 'f)))
    (test? 42 (t!f))
    (test? nil ((fn ())))
    (test? 10 ((fn (x) (- x 2)) 12))
    (= plus '+)
    (test? 3 (plus 1 2))
    (test? 3 ('plus 1 2))
    (= p 'pr)
    (test? "1,2,3" (tostring:p 1 2 3 sep: ","))))

;(define-test identifier
;  (let (a 10
;        b (obj x: 20)
;        f (fn () 30))
;    (test? 10 a)
;    (test? 10 (%literal a))
;    (test? 20 (%literal b |.x|))
;    (test? 30 (%literal f |()|))))

(define-test names
  (withs (a! 0
          b? 1
          -% 2
          ** 3
          break 4)
    (test? 0 a!)
    (test? 1 b?)
    (test? 2 -%)
    (test? 3 **)
    (test? 4 break)))

(define-test =
  (test? 1 (= xx 1))
  (test? 1 xx)
  (test? 2 (= yy 1 zz 2))
  (test? 1 yy)
  (test? 2 zz)
  (let a 42
    (= a 'bar)
    (test? 'bar a)
    (let x (= a 10)
      (test? 10 x)
      (test? 10 a))
    (= a false)
    (test? false a)
    (= a)
    (test? nil a)))

(define-test wipe
  (let x (obj :a :b :c)
    (wipe (x 'a))
    (test? nil (x 'a))
    (test? true (x 'b))
    (wipe (x 'c))
    (test? nil (x 'c))
    (test? true (x 'b))
    (wipe (x 'b))
    (test? nil (x 'b))
    (test? (obj) x)))

(define-test do
  (let a 17
    (do (= a 10)
        (test? 10 a))
    (test? 10 (do a))
    (let b (do (= a 2) (+ a 5))
      (test? a 2)
      (test? b 7))
    (do (= a 10)
        (do (= a 20)
            (test? 20 a)))
    (test? 20 (do (= a 10)
                  (do (= a 20) a))))
  (test? '(%do) (macex '(do))))

(define-test if
  (test? '(if a) (macex '(if a)))
  (test? '(if a b) (macex '(if a b)))
  (test? '(if a b c) (macex '(if a b c)))
  (test? '(if a b c d) (macex '(if a b c d)))
  (test? '(if a b c d e) (macex '(if a b c d e)))
  (if true
      (test? true true)
    (test? true false))
  (if false (test? true false)
      false (test? false true)
    (test? true true))
  (if false (test? true false)
      false (test? false true)
      false (test? false true)
    (test? true true))
  (if false (test? true false)
      true (test? true true)
      false (test? false true)
    (test? true true))
  (test? false (if false true false))
  (test? 1 (if true 1 2))
  (test? 1 (if (let a 10 a) 1 2))
  (test? 1 (if true (do1 1) 2))
  (test? 1 (if false 2 (let a 1 a)))
  (test? 1 (if false 2 true (do1 1)))
  (test? 1 (if false 2 false 3 (let a 1 a)))
  (test? 0 (if false 1 0)))

(define-test case
  (let x 10
    (test? 2 (case x 9 9 10 2 4))
    (test? 2 (case x 9 9 (10) 2 4))
    (test? 2 (case x 9 9 (10 20) 2 4)))
  (let x 'z
    (test? 9 (case x z 9 10))
    (test? 7 (case x a 1 b 2 7))
    (test? 2 (case x a 1 (z) 2 7))
    (test? 2 (case x a 1 (b z) 2 7)))
  (withs (n 0 f (fn () (++ n))) ; no multiple eval
    (test? 'b (case (f) 0 'a 1 'b 'c)))
  (test? 'b ((fn () (case 2 0 (do) 1 'a 2 'b)))))

(define-test while
  (let i 0
    (while (< i 5)
      (if (is i 3) (break) (++ i)))
    (test? 3 i)
    (while (< i 10)
      (++ i))
    (test? 10 i)
    (let a (while (< i 15) (++ i))
      (test? nil a)
      (test? 15 i))
    (let b
        (while (< i 20)
          (if (is i 19)
              (break)
            (++ i)))
      (test? nil b)
      (test? 19 i))
    (test? '(1) (while t (out 1) (break)))
    (test? 42 (while t (break 42)))))

(define-test for
  (let l ()
    (for i 0 4
      (snoc! l i))
    (test? '(0 1 2 3 4) l))
  (test? '(0 1) (with l () (for i 0 1 (snoc! l i))))
  (withs (n 0 l '(a b c d e))
    (forlen i l
      (++ n i)
      (= l '(a b c)))
    (test? 10 n)))

(define-test table
  (test? 10 ((obj a: 10) 'a))
  (test? true ((obj :a) 'a)))

(define-test empty
  (test? true (empty ()))
  (test? true (empty (obj)))
  (test? true (empty ""))
  (test? true (empty #""))
  (test? true (empty #[]))
  (test? true (empty '||))
  (test? false (empty '(1)))
  (test? false (empty '(:a)))
  (test? false (empty (obj :a)))
  (test? false (empty '(b: false)))
  (test? false (empty (fn ())))
  (test? false (empty #\a))
  (test? false (empty false)))

(define-test at
  (let l '(a b c d)
    (test? 'a (l 0))
    (test? 'b (l 1))
    (= (l 0) 9)
    (test? 9 (l 0))
    (= (l 3) 10)
    (test? 10 (l 3))))

(define-test get-set
  (let t (obj)
    (= (t 'foo) 'bar)
    (test? 'bar (t 'foo))
    (test? nil (t "foo"))
    (let k 'foo
      (test? 'bar (t k)))
    (test? 'bar (t (sym:cat "f" "oo"))))
  (withs (t1 (obj) t2 (obj))
    (= ((or nil t1 t2) 'foo) 'bar)
    (test? 'bar (t1 'foo))
    (test? nil (t2 'foo))))

;(define-test each
;  (let t '(1 2 3 :a b: false)
;    (let (a 0 b 0)
;      (each (k v) t
;        (if (number? k)
;            (++ a)
;          (++ b)))
;      (test? 3 a)
;      (test? 2 b))
;    (let a 0
;      (each x t (++ a))
;      (test? 5 a)))
;  (let t '((1) (2) b: (3))
;    (each x t
;      (test? false (atom? x)))
;    (each (x) t
;      (test? false (atom? x)))
;    (each ((x)) t
;      (test? true (number? x)))))

(define-test step
  (let n 0
    (each x '(1 2 3) (++ n x))
    (test? 6 n))
  (let n 0
    (each (x y) '((1 2) (3 4))
      (++ n (+ x y)))
    (test? 10 n))
  (let xs ()
    (let l (list (obj a: 1 b: 2) (obj a: 2 b: 4))
      (each (:a :b) l
        (snoc! xs (+ a b))))
    (test? '(3 6) xs))
  (let l '(a b)
    (each x l
      (if (is x 'a) (snoc! l 'c)
          (is x 'c) (snoc! l 'd)))
    ;(test? '(a b c d) l)
    (test? '(a b c) l)))

(define-test ++
  (let x 2 (++ x) (test? 3 x))
  (let x 2 (test? 3 (++ x)))
  (let x 2 (test? 4 (++ x 2)))
  (let x 2 (test? 2 (++ x 0))))

(define-test --
  (let x 2 (-- x) (test? 1 x))
  (let x 2 (test? 1 (-- x)))
  (let x 4 (test? 2 (-- x 2)))
  (let x 2 (test? 2 (-- x 0))))

(define-test fn
  (let f (fn (n) (+ n 10))
    (test? 20 (f 10))
    (test? 30 (f 20))
    (test? 40 ((fn (n) (+ n 10)) 30))
    (test? '(2 3 4) (map (fn (x) (+ x 1)) '(1 2 3)))))

(define-test def
  (def x 20)
  (def f () 42)
  (test? 20 x)
  (test? 42 (f))
  ((fn ()
     (def f () 38)
     (test? 38 (f))))
  (test? 42 (f)))

(define-test return
  (let a ((fn () 17))
    (test? 17 a))
  (let a ((fn () (if true 10 20)))
    (test? 10 a))
  (let a ((fn () (while false (blah))))
    (test? nil a))
  (let a 11
    (let b ((fn () (++ a)))
      (test? 12 b)
      (test? 12 a)))
  (test? 1 ((fn () (point return (return (if true (return 1) 2)))))))

(mac guard1 (x)
  (letu (ok v)
    `(let (,ok ,v) (guard ,x)
       (list ,ok (if ,ok ,v (details ,v))))))

(define-test guard
  (def error ((o x))
    (err (if (null x) "" (isa!string x) x (writes (unquoted x)))))
  (test? (list false "") (guard1 (error)))
  (test? (list false "") (guard1 (error nil)))
  (test? (list false "false") (guard1 (error false)))
  (test? (list false "t") (guard1 (error true)))
  (test? (list false "42") (guard1 (error 42)))
  (test? '(true 42) (guard1 42))
  (test? '(false "foo") (guard1 (error "foo")))
  (test? '(false "foo") (guard1 (do (error "foo") (error "baz"))))
  (test? '(false "baz") (guard1 (do (guard1 (error "foo")) (error "baz"))))
  (test? '(true 42) (guard1 (if true 42 (error "baz"))))
  (test? '(false "baz") (guard1 (if false 42 (error 'baz)))))

(define-test let
  (let a 10
    (test? 10 a))
  (withs (a 10)
    (test? 10 a))
  (withs (a 11
          b 12)
    (test? 11 a)
    (test? 12 b))
  (withs (a 1)
    (test? 1 a)
    (withs (a 2)
      (test? 2 a))
    (test? 1 a))
  (withs (a 1)
    (withs (a 2)
      (withs (a 3)
        (test? a 3))
      (test? a 2))
    (test? a 1))
  (withs (a 20)
    (test? 20 a)
    (withs (a (+ a 7))
      (test? 27 a))
    (withs (a (+ a 10))
      (test? 30 a))
    (test? 20 a))
  (test? 10 (withs (a 10) a))
  (withs (a (withs (b 12) b))
    (test? 12 a))
  (withs (a (withs (a 10) a))
    (test? 10 a))
  (withs (a (+ (withs (a 0)
                 (= a 10)
                 (+ a 2))
              3))
    (test? a 15))
  ((fn (zz)
     (test? 20 zz)
     (withs (zz 21)
       (test? 21 zz))
     (test? 20 zz))
   20)
  (let q 9
    ((fn ()
       (let q 10
         (test? 10 q))
       (test? 9 q))))
  (test? 0 (+ (abs -1)
              (let abs (fn (x) x)
                (abs -1)))))

(define-test with
  (test? 10 (with x 9 (++ x))))

(define-test whenlet
  (test? nil (whenlet frips (is 'a 'b) 19))
  (test? 19 (whenlet frips 20 (- frips 1)))
  (test? 20 (whenlet (a b) '(19 20) b))
  (test? nil (whenlet (a b) nil b))
  (test? 123 (whenlet a 0 (+ a 123))))

(= zzop 99
   zzap 100)

(withs (zzop 10
        zzap (+ zzop 10)
        (zza zzb) '(1 2 3 a: 10 b: 20))
  (define-test let-toplevel1
    (test? 10 zzop)
    (test? 20 zzap)
    (test? 1 zza)
    (test? 2 zzb)))

(define-test let-toplevel
  (test? 99 zzop)
  (test? 100 zzap))

(define-test reserved
  (withs (end 'zz
          try 'yy
          return 99)
    (test? 'zz end)
    (test? 'yy try)
    (test? '99 return))
  ;(define var (if end return)
  ;  (return (+ if end return)))
  ;(test? 6 (var 1 2 3))
  (def 1+ (x)
    (+ x 1))
  (test? 6 (1+ 5)))

(define-test destructuring
  (let (a b c) '(1 2 3)
    (test? 1 a)
    (test? 2 b)
    (test? 3 c))
  (let (w (x (y) z)) '(1 (2 (3) 4))
    (test? 1 w)
    (test? 2 x)
    (test? 3 y)
    (test? 4 z))
  (let (a b . c) '(1 2 3 4)
    (test? '(3 4) c))
  (let (w (x . y) . z) '(1 (2 3 4) 5 6 7)
    (test? '(3 4) y)
    (test? '(5 6 7) z))
  (let (foo: a) (obj foo: 99)
    (test? 99 a))
  (let (foo: (a b (o c 100))) (obj foo: '(98 99))
    (test? 98 a)
    (test? 99 b)
    (test? 100 c))
  (let ((o :foo)) (obj)
    (test? nil foo))
  (let ((o :foo 99)) (obj)
    (test? 99 foo))
  (let ((o :foo 99)) (obj foo: 42)
    (test? 42 foo))
  (let (foo: a bar: (o b 100) :c) (obj foo: 99)
    (test? 99 a)
    (test? 100 b)
    (test? nil c))
  (let (:foo bar: (baz: (a b c)) (o :quux 404))
       (obj foo: 42 bar: (obj baz: '(1 2 3)))
    (test? 42 foo)
    (test? '(1 2 3) (list a b c))
    (test? 404 quux))
  (let ((o :a 10) baz: ((o :b 20) :foo) :bar)
       (obj baz: (obj foo: 17) bar: '(1 2 3))
    (test? 10 a)
    (test? 20 b)
    (test? 17 foo)
    (test? '(1 2 3) bar))
  (let yy (list 1 2 3)
    (let (xx yy . zz) yy
      (test? 1 xx)
      (test? 2 yy)
      (test? '(3) zz))))

;(define-test let-macro
;  (let-macro ((a () 17)
;              (b (a) `(+ ,a 10)))
;    (test? 17 (a))
;    (test? 42 (b 32))
;    (let-macro ((a () 1))
;      (test? 1 (a)))
;    (test? 17 (a)))
;  (let-macro ((a () 18))
;    (let (b (fn () 20))
;      (test? 18 (a))
;      (test? 20 (b))))
;  (let-macro ((a (x)
;                (let (x 10)
;                  (= x 20))
;                `(+ ,x 1)))
;    (test? 2 (a 1))))

;(define-test let-symbol
;  (let-symbol (a 17
;               b (+ 10 7))
;    (test? 17 a)
;    (test? 17 b)
;    (let-symbol (a 1)
;      (test? 1 a))
;    (test? 17 a))
;  (let-symbol (a 18)
;    (let (b 20)
;      (test? 18 a)
;      (test? 20 b))))

;(define-test define-symbol
;  (define-symbol zzz 42)
;  (test? zzz 42))

;(define-test macros-and-symbols
;  (let-symbol (a 1)
;    (let-macro ((a () 2))
;      (test? 2 (a)))
;    (test? 1 a))
;  (let-macro ((a () 2))
;    (let-symbol (a 1)
;      (test? 1 a))
;    (test? 2 (a))))

;(define-test macros-and-let
;  (let a 10
;    (test? a 10)
;    (let-macro ((a () 12))
;      (test? 12 (a)))
;    (test? a 10))
;  (let b 20
;    (test? b 20)
;    (let-symbol (b 22)
;      (test? 22 b))
;    (test? b 20))
;  (let-macro ((c () 30))
;    (test? 30 (c))
;    (let c 32
;      (test? 32 c))
;    (test? 30 (c)))
;  (let-symbol (d 40)
;    (test? 40 d)
;    (let d 42
;      (test? 42 d))
;    (test? 40 d)))

;(define-test let-unique
;  (let-unique (ham chap)
;    (test? '__ham2 ham)
;    (test? '__chap1 chap)
;    (let-unique (ham)
;      (test? '__ham3 ham))))

(define-test literals
  (test? true true)
  (test? false false)
  (test? true (< -inf -1e10))
  (test? false (< inf -1e10))
  (test? true (is nan nan))
  (test? true (nan? nan))
  (test? true (nan? (- nan)))
  (test? true (nan? (* nan 20)))
  (test? -inf (- inf))
  (test? inf (- -inf))
  (withs (Inf 1 NaN 2 -Inf 'a -NaN 'b)
    (test? Inf 1)
    (test? NaN 2)
    (test? -Inf 'a)
    (test? -NaN 'b)))

(define-test snoc!
  (let l ()
    (snoc! l 'a)
    (snoc! l 'b)
    (snoc! l 'c)
    (test? '(a b c) l)
    ;(test? nil (snoc! () 'a))
    ))

;(define-test drop
;  (let l '(a b c)
;    (test? 'c (drop l))
;    (test? 'b (drop l))
;    (test? 'a (drop l))
;    (test? nil (drop l))))

(define-test last
  (test? 3 (last '(1 2 3)))
  (test? nil (last ()))
  (test? 'c (last '(a b c))))

(define-test append
  (test? '(1 2 3) (+ '(1 2) '(3)))
  (test? '(1 2) (+ () '(1 2)))
  (test? () (+ () ()))
  (test? () (+ nil nil))
  (test? () (+ nil ()))
  (test? () (+ nil))
  (test? () (+ ()))
  (test? '(1) (+ '(1) nil))
  (test? '(a) (+ '(a) ()))
  (test? '(a) (+ nil '(a)))
  (test? '(a) (+ '(a)))
  ;(test? '(a :b) (+ '(a) (list :b)))
  ;(test? '(a b :b) (+ '(a) '(b :b)))
  ;(test? '(a b: 10) (+ '(a :b) (list b: 10)))
  ;(test? '(b: 10) (+ (list :b) '(b: 10)))
  ;(let t (+ '(a b: 1) '(b c: 2))
  ;  (test? 1 (get t 'b))
  ;  (test? 2 (get t 'c))
  ;  (test? 'b (at t 1)))
  )

(define-test reverse
  (test? () (rev ()))
  (test? '(3 2 1) (rev '(1 2 3)))
  ;(test? '(3 2 1 :a) (rev '(1 2 3 :a)))
  )

(define-test map
  (test? () (map (fn (x) x) ()))
  (test? '(1) (map (fn (x) x) '(1)))
  (test? '(2 3 4) (map (fn (x) (+ x 1)) '(1 2 3)))
  ;(test? '(2 3 4 a: 5) (map (fn (x) (+ x 1)) (list 1 2 3 a: 4)))
  ;(test? '(:a) (map (fn (x) x) '(:a)))
  ;(test? '(b: false) (map (fn (x) x) '(b: false)))
  ;(test? '(:a b: false) (map (fn (x) x) '(:a b: false)))
  (let evens (fn (x) (when (is (mod x 2) 0) x))
    (test? '(nil 2 nil 4 nil 6) (map evens '(1 2 3 4 5 6)))
    (test? '(2 4 6) (rem nil (map evens '(1 2 3 4 5 6))))
    ;(test? '(2 4 6 b: 8) (map evens '(1 2 3 4 5 6 a: 7 b: 8)))
    ))

(define-test cut
  (test? '() (cut '()))
  (test? '(a) (cut '(a)))
  (test? '(b c) (cut '(a b c) 1))
  (test? '(b c) (cut '(a b c d) 1 3))
  (test? '(1 2 3) (cut '(1 2 3) 0 10))
  (test? '(2) (cut '(1 2 3) 1 -1))
  (test? '(1) (cut '(1 2 3) -4 1))
  (test? '(1 2 3) (cut '(1 2 3) -4))
  ;(test? '(2 :a) (cut '(1 2 :a) 1))
  ;(test? '(:a b: 2) (cut '(:a b: 2)))
  (let x '(1 2 3)
    (test? '() (cut x (len x))))
  ;(let x '(1 2 3 :a)
  ;  (test? '(:a) (cut x (# x))))
  )

(define-test clip
  (test? "uux" (cut "quux" 1))
  (test? "uu" (cut "quux" 1 3))
  (test? "" (cut "quux" 5))
  (test? "ab" (cut "ab" 0 4))
  (test? "a" (cut "ab" 0 -1))
  (test? "b" (cut "ab" -1)))

;(define-test search
;  (test? nil (search "" "a"))
;  (test? 0 (search "" ""))
;  (test? 0 (search "a" ""))
;  (test? 0 (search "abc" "a"))
;  (test? 2 (search "abcd" "cd"))
;  (test? nil (search "abcd" "ce"))
;  (test? nil (search "abc" "z")))

;(define-test split
;  (test? () (split "" ""))
;  (test? () (split "" ","))
;  (test? (list "a") (split "a" ","))
;  (test? (list "a" "") (split "a," ","))
;  (test? (list "a" "b") (split "a,b" ","))
;  (test? (list "a" "b" "") (split "a,b," ","))
;  (test? (list "a" "b") (split "azzb" "zz"))
;  (test? (list "a" "b" "") (split "azzbzz" "zz")))

(define-test reduce
  (test? 'a (either (reduce (fn (a b) (+ a b)) '()) 'a))
  (test? 'a (either (reduce (fn (a b) (+ a b)) '(a)) 'a))
  (test? 6 (reduce (fn (a b) (+ a b)) '(1 2 3)))
  (test? '(1 (2 3))
         (reduce
          (fn (a b) (list a b))
          '(1 2 3)))
  (test? '(1 2 3 4 5)
         (reduce
          (fn (a b) (+ a b))
          '((1) (2 3) (4 5)))))

(define-test keep
  (test? () (keep (fn (x) x) ()))
  (test? '(0 1 2) (keep (fn (x) x) '(0 1 2)))
  (test? '((1) (2 3)) (keep ~empty '(() (1) () (2 3))))
  (let evens (fn (x) (is (mod x 2) 0))
    (test? '(6) (keep evens '(5 6 7)))
    (test? '(2 4 6) (keep evens '(1 2 3 4 5 6)))
    ;(test? '(2 4 6 b: 8) (keep evens '(1 2 3 4 5 6 a: 7 b: 8)))
    ))

(define-test mem
  (test? '(x y z) (mem 'x '(x y z)))
  (test? '(7) (mem 7 '(5 6 7)))
  (test? nil (mem 'baz '(no can do))))

(define-test find
  (test? nil (find (fn (x) x) ()))
  (test? 7 (find (fn (x) x) '(7)))
  (test? 7 (find (fn (x) (is x 7)) '(2 4 7)))
  ;(test? true (find (fn (x) (is x 7)) '(2 4 foo: 7)))
  ;(test? true (find (fn (x) (is x true)) '(2 4 :bar)))
  (test? 7 (find 7 '(2 4 7)))
  ;(test? true (mem 7 '(2 4 foo: 7)))
  ;(test? true (mem true '(2 4 :bar)))
  )

;(define-test first
;  (test? nil (first (fn (x) x) ()))
;  (test? 7 (first (fn (x) x) '(7)))
;  (test? true (first (fn (x) (is x 7)) '(2 4 7)))
;  (test? 4 (first (fn (x) (and (> x 3) x)) '(1 2 3 4 5 6))))

(define-test sort
  (test? '(a b c) (sort < '(c a b)))
  (test? '(3 2 1) (sort > '(1 2 3))))

(define-test type
  (test? true (isa!string "abc"))
  (test? false (isa!string 17))
  (test? false (isa!string '(a)))
  (test? false (isa!string true))
  (test? false (isa!string (obj)))
  (test? false (number "abc"))
  (test? true (number 17))
  (test? false (number '(a)))
  (test? false (number true))
  (test? false (number (obj)))
  (test? false (isa!bool "abc"))
  (test? false (isa!bool 17))
  (test? false (isa!bool '(a)))
  (test? true (isa!bool true))
  (test? false (isa!bool (obj)))
  (test? true (atom nil))
  (test? true (atom "abc"))
  (test? true (atom 42))
  (test? true (atom true))
  (test? true (atom (fn ())))
  (test? false (atom '(1)))
  (test? true (atom (obj)))
  (test? true (isa!table (obj a: 10)))
  (test? false (isa!table null))
  (test? false (isa!table 1))
  (test? false (isa!table 'zz))
  (test? false (isa!table (fn ()))))

;(define-test str
;  (define f (x) x)
;  (let (l () l2 ())
;    (= (get l f) true)
;    (= (get l2 (target js: (str l) lua: l)) true)
;    (let k (target js: f lua: 'function)
;      (test? (cat "(" k ": true)") (str l))
;      (test? (cat "((" k ": true): true)") (str l2)))))

(define-test apply
  (test? 4 (apply (fn (a b) (+ a b)) '(2 2)))
  (test? '(2 2) (apply (fn a a) '(2 2)))
  (test? '(2 2 a: 2) (kwapply (fn a a) nil '(2 2 a: 2)))
  ;(let t '(1)
  ;  (= (get t 'foo) 17)
  ;  (test? 17 (apply (fn a (get a 'foo)) t)))
  (test? 42 (apply (fn (:foo) foo) (list foo: 42)))
  (test? 42 (apply (fn ((:foo)) foo) (list (obj foo: 42))))
  (test? 116 (apply + 1 5 '(100 10)))
  (test? #\f (apply "foo" '(0))))

(define-test eval
  (test? 4 (eval '(+ 2 2)))
  (test? 5 (eval '(let a 3 (+ 2 a))))
  (test? 9 (eval '(do (def x 7) (+ x 2))))
  (test? 6 (eval '(apply + '(1 2 3)))))

(define-test call
  (let f (fn () 42)
    (test? 42 (call f)))
  (let fs (list (fn () 1) (fn () 10))
    (test? '(1 10) (map call fs)))
  (let f (fn (x y) (+ x y 1))
    (test? 42 (call f 40 1)))
  (let f (fn (x y :op) (op x y 1))
    (test? 42 (call f op: + 40 1))
    (test? 42 (call f op: '+ 40 1))))

(define-test parameters
  (test? 42 ((fn ((a)) a) '(42)))
  (let f (fn (a (b c)) (list a b c))
    (test? '(1 2 3) (f 1 '(2 3))))
  (let f (fn (a (b . c) . d) (list a b c d))
    (test? '(1 2 (3 4) (5 6 7)) (f 1 '(2 3 4) 5 6 7)))
  (let f (fn (a (b . c) . d) (list a b c d))
    (test? '(1 2 (3 4) (5 6 7)) (apply f '(1 (2 3 4) 5 6 7))))
  (test? '(3 4) ((fn (a b . c) c) 1 2 3 4))
  (let f (fn (w (x . y) . z) (list y z))
    (test? '((3 4) (5 6 7)) (f 1 '(2 3 4) 5 6 7)))
  (test? 42 ((fn (:foo) foo) foo: 42))
  (test? 42 (apply (fn (:foo) foo) '(foo: 42)))
  (test? 42 ((fn ((:foo)) foo) (obj foo: 42)))
  ;(let f (fn (a bar: b (:foo)) (list a b foo))
  ;  (test? '(10 20 42) (f 10 bar: 20 (obj foo: 42))))
  ;(let f (fn (a bar: b (:foo)) (list a b foo))
  ;  (test? '(10 20 42) (apply f (list 10 bar: 20 (obj foo: 42)))))
  (test? 1 ((fn ((o a) :b) (+ (or a 0) b)) b: 1))
  (test? 1 (apply (fn ((o a) :b) (+ (or a 0) b)) (list b: 1)))
  (let f (fn args args)
    (test? '(1 2 3) (f 1 2 3)))
  (let f (fn args args)
    (test? '(1 2 3) (apply f (list 1 2 3))))
  (let l ()
    (def f (:a) (snoc! l a) a)
    (def g (a b :c) (snoc! l (list a b c)) c)
    (test? 42 (f a: (g (f a: 10) (f a: 20) c: (f a: 42))))
    (test? '(10 20 42 (10 20 42) 42) l))
  (let l nil
    (def f x (= l x))
    (def g (a b) (+ a b))
    (f (g 1 2 #|foo: 7|#))
    (test? '(3) l))
  (let l nil
    (def f x (= l x) 10)
    (def g (a b) (+ (f) a b))
    (test? 13 (g 1 2 #|foo: 7|#))
    (test? '() l))
  (let l nil
    (def f (x . ys) (= l ys))
    (def g () nil)
    (f 1 'x g)
    (test? (list 'x g) l)))

(define-test unicode
  (test? "abc@@example.com" (coerce '(#\a #\b #\c #\@ #\e #\x #\a #\m #\p #\l #\e #\. #\c #\o #\m) 'string))
  (test? "abc@@example.com" (coerce '( 97  98  99  64 101 120  97 109 112 108 101  46  99 111 109) 'string))
  (test? "ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็ ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็ ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็" (coerce (coerce "ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็ ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็ ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็" 'bytes 'utf8) 'string 'utf8))
  (test? "" (coerce (list) 'string)))

(define-test accum
  (test? '(1 (1 2) (1 2 3)) (accum a (a 1) (a 1 2) (a 1 2 3)))
  (test? '(1 (1 2) (1 2 3)) (accum a (a 1) (a 1 2) (a 1 2 3) (map a (a))))
  (test? '((1 (1 2) (1 2 3))) (accum a (a 1) (a 1 2) (a 1 2 3) (apply a (a))))
  (test? '(42) (accum a (a 1) (a 1 2) (a 1 2 3) (a) (a 42))))

(define-test pr
  (test? "abc" (tostring:pr 'a 'b 'c))
  (test? "a.b.c" (tostring:apply pr '(a b c) sep: "."))
  (test? "abc\n" (tostring:prn 'a 'b 'c))
  (test? "a b c" (tostring:prs 'a 'b 'c))
  (test? 'a (pr file: (outstring) 'a 'b 'c))
  (test? "a c" (tostring:prt 'a nil 'c sep: " "))
  (test? nil (prt file: (outstring) nil 'b 'c)))

(define-test sets
  (test? '(a b c d) (union '(c a b) '(d b)))
  (test? '(a b c d) (union '(a b c) '(b d) :sorted))
  (test? '(d c b a) (union '(c a b) '(d b) test: >))
  (test? '(a c) (difference '(c a b) '(d b)))
  (test? '(a c) (difference '(a b c) '(b d) :sorted))
  (test? '(b) (intersect '(c a b) '(d b)))
  (test? '(b) (intersect '(a b c) '(b d) :sorted))
  (test? '((b 2) (c 3)) (difference '((a 1) (b 2) (c 3))
                                    '((a 1) (d 4))
                                    key: car))
  (test? '() (union))
  (test? '(a) (union '(a)))
  (test? '(a b c) (union '(a) '(b) '(c)))
  (test? '(a b c) (union 'a 'b 'c))
  (test? '(a b c) (union '(a) 'b '(c)))
  (test? '() (intersect '(a) '()))
  (test? '(a) (intersect '(a)))
  (test? '(a) (difference '(a b c) 'b 'c)))

(define-test brackets
  (def f ((o :op +) . args)
    (apply op args))
  (test? '(2 3 4) (map [f _ 1] '(1 2 3)))
  (test? '(0 1 2) (map [f _ 1 op: -] '(1 2 3))))

(define-test andf
  (let 1st (fn (:kws . args) (car args))
    (test? "" (tostring (1st&pr nil 'a 'b sep: " ")))
    (test? "a b" (tostring (1st&pr 'a 'b sep: " ")))
    (test? "a b" (tostring ((do 1st&pr) 'a 'b sep: " ")))
    (test? "" (tostring ((cand 1st pr) nil 'a 'b sep: " ")))
    (test? "a b" (tostring ((cand 1st pr) 'a 'b sep: " ")))
    (test? "a b" (tostring ((do (cand 1st pr)) 'a 'b sep: " ")))))

(define-test part
  (test? "123" (tostring ((part pr sep: " ") 1 2 3 sep: ""))))

(define-test scheme
  #'(let ([a 1] [b 2])
      (+ a b))
  #`(let ([a 1] [b 2])
      #,(test? 3 #`(+ a b)))
  (let a 1
    #`(let ([b 2])
        #,(test? 3 #`(+ #,a b)))))

(define-test cons
  (test? '(a) (cons 'a))
  (test? '(a . b) (cons 'a 'b))
  (test? '(a b . c) (cons 'a 'b 'c))
  (test? '(nil) (cons))
  (test? '(nil . nil) (cons))
  (test? '(a . nil) (cons 'a)))

(define-test pairwise
  ; zero args should always return true
  (each op (list < <= is isnt >= >)
    (test? true (op)))

  ; (op x) is short for [op _ x]
  (test? true (isa!fn (is 3)))
  (test? true (isa!fn (isnt 3)))
  (test? true (isa!fn (< 3)))
  (test? true (isa!fn (> 3)))
  (test? true (isa!fn (<= 3)))
  (test? true (isa!fn (>= 3)))
  (test? false ((is 3) 2))
  (test? true  ((is 3) 3))
  (test? false ((is 3) 4))
  (test? true  ((isnt 3) 2))
  (test? false ((isnt 3) 3))
  (test? true  ((isnt 3) 4))
  (test? true  ((< 3) 2))
  (test? false ((< 3) 3))
  (test? false ((< 3) 4))
  (test? false ((> 3) 2))
  (test? false ((> 3) 3))
  (test? true  ((> 3) 4))
  (test? true  ((<= 3) 2))
  (test? true  ((<= 3) 3))
  (test? false ((<= 3) 4))
  (test? false ((>= 3) 2))
  (test? true  ((>= 3) 3))
  (test? true  ((>= 3) 4))

  ; (op x y z) is short for (and (op x y) (op y z))
  (test? true (is #\a #\a #\a))
  (test? false (is #\a #\a #\z))
  (test? false (isnt #\a #\a #\a))
  (test? false (isnt #\a #\a #\z))
  (test? true (isnt #\a #\b #\c))
  (test? true (isnt #\a #\b #\a))
  (test? true (<= #\a #\a #\z))
  (test? true (>= #\z #\a #\a))
  (test? false (< #\a #\a #\z))
  (test? false (> #\z #\a #\a))
  (test? false (<= #\a #\space #\z))
  (test? false (>= #\z #\space #\a))
  (test? false (< #\a #\space #\z))
  (test? false (> #\z #\space #\a)))

(define-test complement
  (test? true ~false)
  (test? false ~true)
  (test? true (~no true))
  (test? false (~no false))
  (test? true (call ~no true))
  (test? false (call ~no false))
  (test? true ((~is 1) 2))
  (test? false ((~is 1) 1)))

(define-test *
  (test? "   " (* 3 " "))
  (test? "   " (* " " 3))
  (test? nil (* nil 3))
  (test? nil (* 3 nil))
  (test? '(a a a) (* '(a) 3))
  (test? '(a a a) (* 3 '(a)))
  (test? "" (* 0 " "))
  (test? nil (* '(a) 0)))

(define-test nil
  (test? true (isa!nil nil))
  (test? true (isa!nil (list)))
  (test? true (isa!nil '()))
  (test? false (isa!nil '(a)))
  (test? false (isa!nil 'a))
  (test? nil (coerce (list) 'nil)))

(define-test values
  (let (values x) 1
    (test? 1 x))
  (let (values x) (values 1)
    (test? 1 x))
  (let (values x) (values 1 2)
    (test? 1 x))
  (let (values x y) 1
    (test? x 1)
    (test? y nil))
  (def f (x y) (values x y))
  (let (values x y) (f 1 2)
    (test? '(1 2) (list x y)))
  (let (values x) (f 1 2)
    (test? 1 x))
  (let (values x y) (f 1 2)
    (test? 1 x))
  (let (values x y z) (f 1 2)
    (test? 1 x)
    (test? 2 y)
    (test? nil z)))

(define-test param
  (test? "hi" (let (param stdout) (outstring)
                (pr "hi")
                (inside (stdout))))
  (test? "hi" (inside (with (param stdout) (outstring)
                        (pr "hi"))))
  (test? (stderr) (with (param stdout) (stderr)))
  (test? 1 (with (param (#'make-parameter 1)) 2))
  (let p (#'make-parameter 1)
    (test? 2 (with (param p) 2
               (test? (p) 2)))
    (test? 1 (p))))

run-tests

